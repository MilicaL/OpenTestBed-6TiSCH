#! /usr/bin/python
# -*- coding: UTF-8 -*-

import sys, time, json, pprint
import paho.mqtt.client as mqttClient
import datetime
import pandas as pd
import socket

#### we need fake server in order to avoid sending ICMP to uinject packet sender (port unreachable)
port  = 61617 #57521 #61617 # 45312 #
ipaddr = 'localhost' #'bbbb::1'
socket_handler = socket.socket(socket.AF_INET6,socket.SOCK_DGRAM)
socket_handler.bind((ipaddr, port))
####

SLOTDURATION = 40 # in ms

input_list = []
 
def on_connect(client, userdata, flags, rc):
 
    if rc == 0:
 
        print("Connected to broker")
 
        global Connected                #Use global variable
        Connected = True                #Signal connection 
 
    else:
 
        print("Connection failed")


def on_message(client, userdata, message):

    try:
       ctime = datetime.datetime.now() # message creation/arrival time
       #print ctime
       j = json.loads(message.payload)
       j['ctime'] = ctime
       input_list.append(j)
       pprint.pprint(j)
    except:
       print "Exception:"
       print "Message received: " + message.payload

    #df = pd.DataFrame(input_list)
    #print df.to_string()
    print "Press Enter to stop test..."
 
Connected = False   #global variable for the state of the connection
 
broker_address= "127.0.0.1" #"iad.duckdns.org" #"broker.hivemq.com"  #Broker address
#broker_address="argus.paris.inria.fr"

port = 1883                         #Broker port
user = "uinject"                    #Connection username
password = "stats"            #Connection password

client = mqttClient.Client("uinject_stats")               #create new instance
client.username_pw_set(user, password=password)    #set username and password
client.on_connect= on_connect                      #attach function to callback
client.on_message= on_message                      #attach function to callback
 
client.connect(broker_address, port=port)          #connect to broker
 
client.loop_start()        #start the loop
 
while Connected != True:    #Wait for connection
    time.sleep(0.1)
 
#client.subscribe("opentestbed/uinject/arrived",qos=2) 
client.subscribe("opentestbed/uinject/pkt_info",qos=2) 

"""
try:
    while True:
        time.sleep(1)
 
except KeyboardInterrupt:
    print "exiting"
    client.disconnect()
    client.loop_stop()
"""

try:
   raw_input("Press Enter to stop test...")
except:
   pass

df = pd.DataFrame(input_list) # ne treba ga sortirati po vremenu dolaska uinject pakata posto je input_list sortirana samim nacinom pravljenja
df['latency_ms']=df['latency']*SLOTDURATION # da ljudima bude prirodnije izrazeno kasnjenje

# simulacija efekata na mrezi
#df = pd.concat([df]*2, ignore_index=True) # simulacija duplicated paketa
#df = df.sample(frac=1) # simulacija out-of-order
#df.drop(df.index[::3],inplace=True)   # simulacija gubitka

print df
# za eventualni postprocessing da se ima
df.to_pickle('last_uinject_df.pkl')


# pomocna funkcija za olaksavaje printanja output-a
def printer(title, tekst):
    print '>>> ' + title + ':'
    print tekst
    print '-'*70


# da uzmemo u obzir cinjenicu da je counter 2B => max 65535
def round_counter(row):
    if (row['counter']-row['prev_counter']) >= 0:
        return row['counter']-row['prev_counter']
    else:
        return row['counter']+(65536-row['prev_counter'])


for mote, group in df.groupby(df['src_id']):

    # pravljenje privremenog df-a koji se odnosi samo na taj mote i dodavanje pomocnih polja
    group_df = group.copy()


    #group_df.drop(group_df.index[5],inplace=True)   # simulacija gubitka

    # ovo radimo zbog out-of-order dolazaka paketa.
    group_df.sort_values(by=['counter'], inplace=True)

    # za potrebe pracenja gubitaka paketa
    group_df['prev_counter'] = group_df.counter.shift(1)
    group_df['diff'] = group_df.apply(lambda row: round_counter(row), axis=1)


    # za potrebe out-of-order analize
    odf = group.copy() 
    #odf['prev_counter'] = odf.counter.shift(1)
    #odf['diff'] = odf['counter'] - odf['prev_counter']
    odf['tmp_max'] = pd.np.nan # da nam drzi so-far-max
    # ovo je sporo?
    for i,v in odf.iterrows():                                        
       odf.loc[i,'tmp_max'] = odf.loc[:i]['counter'].max()



    # ovo radimo zbog duplicated paketa (uzimamo prvi pristigli ostale izbacujemo)
    group_df = group_df[group_df['diff'] != 0.]

    # za potrebe pracenja perioda izmedju slanja uinject paketa
    group_df['prev_init_asn'] = group_df.asn.shift(1)
    group_df['inter_asn'] = (group_df['asn'] - group_df['prev_init_asn'])*SLOTDURATION/1000.

    #print group_df.to_string()


    # za potrebe duplicated reception detection
    ddf = group.copy()
    ss = ddf.groupby(['counter']).size()
    ss = ss - 1


    # umjesto zaglavlja
    print '#'*70
    print mote
    print '#'*70


    # ukupno primljenih paketa
    printer('Total packets arrived', str(len(group_df)))
    printer('Total missing packets (between first and last arrived packet)', str(group_df[1:]['diff'].sum()-group_df[1:]['diff'].count()))
    printer('Calculated PDR in %', str((len(group_df)/(group_df.iloc[-1, 1]-group_df.iloc[0, 1]+1.))*100))
    printer('Total time between 1st and last pkt arrived', str(group_df.iloc[-1, 2] - group_df.iloc[0, 2]))
    printer('Packets delay stats (in ms)',group_df['latency_ms'].describe().to_string())
    printer('Packets delay stats (in time slots)', group_df['latency'].describe().to_string())
    #printer('Packets payload stats (in Bytes)',
            #group_df['payload_B'].describe().to_string())
    #printer('Total bytes received', str(group_df['payload_B'].sum()))
    #printer('Calculated useful information transfer speed', str((group_df['payload_B'].sum(
    #)/((group_df.iloc[-1, 5]-group_df.iloc[0, 4])*SLOTDURATION/1000.))*8.) + ' bps')
    printer('Period (in seconds) between consecutive uinject packets stats', group_df[group_df['diff'] == 1.]['inter_asn'].describe())

    printer('Number of duplicated packets', str(ss.sum()))

    #printer('Number of out-of-order packets', str(len(odf[odf['diff']<0]))) # posto ako dodje naknadno imace manji pkt_num
    printer('Number of out-of-order arrived packets', str(odf[odf['counter'] != odf['tmp_max']].shape[0])) # novi (sporiji) nacin

    printer('Duty Cycle stats', group_df['dutyCycle'].describe().to_string())
    printer('numCellsUsedRx stats', group_df['numCellsUsedRx'].describe().to_string())
    printer('numCellsUsedTx stats', group_df['numCellsUsedTx'].describe().to_string())


print "exiting"
socket_handler.close()
client.disconnect()
client.loop_stop()

sys.exit()

